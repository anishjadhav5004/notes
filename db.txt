trucate cant be rolled backed bt delet from can

cursor is used for  line to line changes in db bcoz usually changes happens in db in group or in a set
üóëÔ∏è DELETE ‚Üí Removes selected rows, slower, safer, reversible.
üí£ TRUNCATE ‚Üí Removes all rows instantly, faster, resets identity, not reversible.

‚úÖ Yes, in some databases (like SQL Server, PostgreSQL, and Oracle),
you can use TRUNCATE inside a transaction, and you can roll it back if you don‚Äôt commit yet.

‚ùå But in others (like MySQL with MyISAM engine),
TRUNCATE auto-commits ‚Äî it can‚Äôt be rolled back even if you‚Äôre inside a transaction.

upsert in tsql

merge into table1 as Target
  using( VALUES (1, 'Anish') ) as source(id,name)
  on Target.id = source.id
when matched then
update Target
 set Target.name = source.name

when not matched then
  insert(name)
  values(source.name)

cte : common table express 
 this is inroduced to store result of any query once nd can be used multiple time , which saves time of calculating same thing again nd again 
   
 recursive cte :
  WITH cte_name AS
(
    -- 1Ô∏è‚É£ Anchor Query (Base case)
    SELECT column_list
    FROM table
    WHERE condition

    UNION ALL

    -- 2Ô∏è‚É£ Recursive Query
    SELECT column_list
    FROM table t
    INNER JOIN cte_name c
        ON join_condition
)
SELECT * FROM cte_name;


# Full-Text Search (FT Search) ‚Äî Technical Note

## What is it?

Full-Text Search (FTS) is a technique used to search through the **entire content** of text data (documents, records, fields) rather than just metadata or indexed keywords.

-----

## How it Works

1. Text is **tokenized** ‚Äî broken into individual words/terms.
1. Tokens are **indexed** ‚Äî stored in an inverted index (word ‚Üí document mapping).
1. At query time, the engine **matches** the query against the index and returns ranked results.

-----

## Key Concepts

|Concept              |Description                                        |
|---------------------|---------------------------------------------------|
|**Inverted Index**   |Maps each word to the documents containing it      |
|**Tokenization**     |Splitting text into searchable tokens              |
|**Stemming**         |Reducing words to root form (running ‚Üí run)        |
|**Stop Words**       |Common words ignored during indexing (the, and, is)|
|**Relevance Ranking**|Scoring results by how well they match the query   |
|**Boolean Search**   |Using AND, OR, NOT operators in queries            |

-----

## Common Use Cases

- Database text search (PostgreSQL, MySQL)
- Search engines (Google, Bing)
- E-commerce product search
- Log & error analysis
- Document management systems
- Chat history search

-----

## Tools & Technologies

|Tool                  |FTS Support                  |
|----------------------|-----------------------------|
|**Elasticsearch**     |Core feature, highly scalable|
|**PostgreSQL**        |`tsvector` / `tsquery`       |
|**MySQL**             |`FULLTEXT` index             |
|**Redis (RediSearch)**|`FT.SEARCH` command          |
|**SQLite**            |Built-in FTS5 module         |
|**MongoDB**           |`$text` operator             |

-----

## Example (PostgreSQL)

```sql
-- Create index
CREATE INDEX idx_fts ON articles USING GIN(to_tsvector('english', body));

-- Search query
SELECT * FROM articles
WHERE to_tsvector('english', body) @@ to_tsquery('machine & learning');
```

## Example (Redis FT.SEARCH)

```bash
FT.SEARCH myIndex "full text query" LIMIT 0 10
```

-----

## FTS vs LIKE Query

|Feature            |LIKE|Full-Text Search |
|-------------------|----|-----------------|
|Speed on large data|Slow|Fast (uses index)|
|Relevance ranking  |No  |Yes              |
|Stemming support   |No  |Yes              |
|Scalability        |Poor|High             |

-----

*Note: FTS is ideal for large, unstructured text datasets where speed and relevance matter.*


